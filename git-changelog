#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2011 Martin Ueding <dev@martin-ueding.de>

import argparse
import itertools
import os
import re
import subprocess
import sys

# TODO Use git's default pager if output is going to a TTY.

def has_git_dir():
    with open(os.devnull, 'w') as null:
        return subprocess.call(["git", "rev-parse", "--show-toplevel"], stdout=null, stderr=null) == 0

    return True


def is_list_all():
    if options.list_all:
        return True

    try:
        with open(os.devnull, 'w') as null:
            return subprocess.check_output(["git", "config", "--get", "changelog.listall"], stderr=null).strip() == "true"
    except subprocess.CalledProcessError as e:
        return False


def load_regex():
    if options.regex != None:
        return options.regex

    try:
        with open(os.devnull, 'w') as null:
            return subprocess.check_output(["git", "config", "--get", "changelog.filter"], stderr=null).strip()
    except subprocess.CalledProcessError as e:
        return None


def parse_args():
    parser = argparse.ArgumentParser(description="Generate changelog from annotated tags.")
    parser.add_argument('-a', '--all', dest="list_all", default=False, action='store_true', help="Show tags from all branches (default: %(default)s")
    parser.add_argument('--filter', dest="regex", default=None, help="Regex to filter tags (default: %(default)s")
    global options
    options = parser.parse_args()


def generate_filter_tag_function():
    regex = load_regex()

    if regex is None:
        def filter_tag(tag):
            return True

    else:
        pattern = re.compile(regex)

        def filter_tag(tag):
            matcher = pattern.match(tag)
            return matcher is not None

    return filter_tag


def generate_tag_list():
    # Get the tag description. Split the lines, remove the last empty line.
    all_tags = subprocess.check_output(["git", "tag"]).split('\n')[:-1]

    if is_list_all():
        tags = sorted(all_tags)[::-1]
    else:
        # The above list only gives us a list of all tags. We are interested in
        # the correct order in the repo and only the tags that are on the
        # current branch. `git log` gives that, but also branch names.
        log = subprocess.check_output(["git", "log", "--simplify-by-decoration", "--format=%d"]).split('\n')

        tags = []
        for log_entry in log:
            # There are a couple of empty lines there.
            if len(log_entry) == 0:
                continue

            log_entry_refs = log_entry[2:-1].split(', ')
            for ref in log_entry_refs:
                if ref in all_tags:
                    tags.append(ref)

    return filter(generate_filter_tag_function(), tags)


def generate_changelog(tags):
    # Iterate through the tags.
    for tag in tags:
        # Get the description for the tag.
        git_show = subprocess.check_output(["git", "show", tag]).split('\n')

        # If this is an annotated tag, it starts with "tag …", if it is a
        # lightweight tag, it starts with "commit …". Since lightweight tags do
        # not carry any description, we can discard them.
        if git_show[0][:3] != "tag":
            continue

        for line, i in zip(git_show, itertools.count()):
            # If the PGP signature starts, the entry is over.
            if line == "-----BEGIN PGP SIGNATURE-----":
                break

            # If the current line is empty, the next might be commit. So this
            # might be the last line.
            if len(line) == 0 and git_show[i+1][:7] == "commit ":
                break


            # Print the line from the tag message.
            if i >= 4:
                print "    "+line

            # Print the tag name.
            elif i == 0:
                print line[4:]


def main():
    parse_args()

    if not has_git_dir():
        print "Error: This is not a git repository."
        sys.exit(1)

    generate_changelog(generate_tag_list())


if __name__ == "__main__":
	main()
